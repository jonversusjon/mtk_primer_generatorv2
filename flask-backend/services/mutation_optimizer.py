from typing import Dict, List
from Bio.Seq import Seq
import numpy as np
from itertools import product
from tqdm import tqdm
import logging

from services.base import debug_context
from services.debug.debug_mixin import DebugMixin
from services.debug.debug_utils import MutationDebugger
from config.logging_config import logger
from .utils import GoldenGateUtils


class MutationOptimizer(DebugMixin):
    """
    MutationOptimizer Module

    This module optimizes mutation combinations generated by the MutationAnalyzer module
    for Golden Gate assembly compatibility. It evaluates alternative codon mutations based on
    sticky-end compatibility, selecting sets of mutations that satisfy the Golden Gate cloning criteria.

    Output Data Structure:
        The get_all_mutations function returns a dictionary keyed by "mutation_{recognition_site_position}", where each value is a dictionary with:
            - "position": The recognition site position.
            - "sequence": The recognition site sequence.
            - "frame": The reading frame.
            - "strand": The DNA strand.
            - "enzyme": The enzyme name.
            - "codons": A list of dictionaries for each codon, each containing:
                    • "codon_original_sequence": The original codon sequence.
                    • "context_position": The codon position in the context sequence.
                    • "amino_acid": The encoded amino acid.
                    • "alternative_codons": A list of dictionaries for each valid alternative codon, each containing:
                            - "seq": The alternative codon sequence.
                            - "usage": The codon usage frequency.
                            - "mutations": A 3-tuple of integers indicating changes (1 for a mutation, 0 otherwise).
                            - "changes_in_site": A list of codon index positions (0, 1, or 2) where the candidate alters the recognition region.
                            - "sticky_ends": A dictionary keyed by "position_{codon_index}" that contains:
                                    • "top_strand": A list of dictionaries, each with:
                                            - "seq": The overhang sequence.
                                            - "overhang_start_index": The starting index in the context.
                                    • "bottom_strand": A list of dictionaries with corresponding reverse-complement data.
                            - "mutated_context": The context sequence with the codon replaced by the alternative codon.
                            - "mutation_positions_in_context": A list of indices in the context where the mutation occurs.

    Output:
        - optimized_mutations (List[Dict]): A list of mutation sets, where each mutation set
        represents a combination of mutations that is fully compatible according to the Golden Gate
        sticky-end assembly rules. Each mutation entry within a set contains:
            • "site": recognition site identifier (e.g., "mutation_477").
            • "position": recognition site position.
            • "original_codon_sequence": the original codon sequence.
            • "alternative_codon_sequence": the selected alternative codon.
            • "mutated_base_index": position of the mutation within the recognition site.
            • "overhangs": Dict containing "overhang_options", a list with:
                    - "top_overhang": dict {"seq": str, "overhang_start_index": int}
                    - "bottom_overhang": dict {"seq": str, "overhang_start_index": int}
                    - "overhang_start_index": int
            • "mutated_context": DNA context suitable for primer design around the mutation.
            - "mutation_positions_in_context": A list of indices in the context where the mutation occurs.

        - compatibility_matrices (List[np.ndarray]): List of N-dimensional numpy arrays corresponding
        to each mutation set, indicating compatible (1) and incompatible (0) overhang combinations.
        The compatibility matrix list is aligned with the mutation set list, where each matrix
        corresponds to the respective mutation set.

    Entry and Exit Point:
        - optimize_mutations is the orchestrator function that serves as the entry and exit point of the module,
        coordinating mutation set generation, compatibility analysis, and filtering steps.
    """

    def __init__(self, verbose: bool = False, debug: bool = False):
        self.logger = logger.getChild("MutationOptimizer")
        self.utils = GoldenGateUtils()
        self.verbose = verbose
        self.debug = debug
        self.debugger = MutationDebugger() if self.debug else None

        if self.debug:
            self.logger.info(
                "🔍 Debug mode enabled with detailed logging and validation")

        self.compatibility_table = self.utils.load_compatibility_table(
            'static/data/compatibility_table.bin')
        self.logger.debug(
            "MutationOptimizer initialized with compatibility table.")
        if self.verbose:
            self.logger.info("MutationOptimizer is running in verbose mode.")
        if self.debug:
            self.validate(self.compatibility_table is not None,
                          "Compatibility table loaded successfully")
            self.validate(isinstance(self.compatibility_table,
                          np.ndarray), "Compatibility table is a numpy array")

    @DebugMixin.debug_wrapper
    def optimize_mutations(self, mutation_options: Dict) -> List[Dict]:
        with debug_context("mutation_optimization"):
            # 1. Generate all possible mutation sets
            self.log_step("Generate Mutation Sets",
                          "Creating all possible mutation combinations")
            mutation_sets = self.generate_mutation_sets(mutation_options)

            # 2. Create compatibility matrices for each mutation set
            self.log_step("Compute Compatibility",
                          "Creating compatibility matrices")
            matrices = self.create_compatibility_matrices(mutation_sets)

            # 3. Filter out mutation sets without a single compatible combination
            self.log_step("Filter Compatible Mutations",
                          "Removing incompatible mutation sets")
            optimized = self.filter_compatible_mutations(
                mutation_sets, matrices)

            return optimized, matrices

    @DebugMixin.debug_wrapper
    def generate_mutation_sets(self, mutation_options: dict) -> list:
        self.validate(
            mutation_options and isinstance(mutation_options, dict),
            f"Received {len(mutation_options)} mutation option sites"
        )
        mutation_choices = []
        for site_key, site_data in mutation_options.items():
            self.log_step(
                "Process Site", f"Processing site {site_key} at position {site_data['position']}")
            mutation_entries = []
            # Iterate through each codon in the site.
            for codon in site_data.get("codons", []):
                # Iterate through each alternative codon option.
                for alt in codon.get("alternative_codons", []):
                    # Build overhang options from the sticky_ends.
                    overhang_options = []
                    for sticky_key, sticky_val in alt.get("sticky_ends", {}).items():
                        top_list = sticky_val.get("top_strand", [])
                        bottom_list = sticky_val.get("bottom_strand", [])
                        for idx in range(len(top_list)):
                            top_option = top_list[idx]
                            bottom_option = bottom_list[idx] if idx < len(
                                bottom_list) else {}
                            overhang_options.append({
                                "top_overhang": top_option,
                                "bottom_overhang": bottom_option,
                                "overhang_start_index": top_option.get("overhang_start_index")
                            })
                    mutation_entry = {
                        "site": site_key,
                        "position": site_data.get("position"),
                        "original_codon_sequence": codon.get("codon_original_sequence"),
                        "alternative_codon_sequence": alt.get("seq"),
                        # Select the first mutation index if available.
                        "mutated_base_index": alt.get("changes_in_site", [None])[0],
                        "overhangs": {"overhang_options": overhang_options},
                        "mutated_context": alt.get("mutated_context"),
                        "mutation_positions_in_context": alt.get("mutation_positions_in_context")
                    }
                    mutation_entries.append(mutation_entry)
            self.validate(
                mutation_entries, f"Found {len(mutation_entries)} mutation entries for {site_key}")
            mutation_choices.append(mutation_entries)

        # Generate the Cartesian product of mutation entries across sites.
        all_sets = [list(combo) for combo in product(*mutation_choices)]
        if self.debug:
            expected = np.prod([len(choices) for choices in mutation_choices])
            self.validate(
                len(all_sets) == expected,
                f"Created {len(all_sets)} mutation sets (expected: {expected})",
                {"sites": len(mutation_choices)}
            )
        return all_sets

    @DebugMixin.debug_wrapper
    def create_compatibility_matrices(self, mutation_sets: List[Dict]) -> List[np.ndarray]:
        compatibility_matrices = []
        for mutation_set in tqdm(mutation_sets, desc="Processing Mutation Sets", unit="set"):
            keys = list(range(len(mutation_set)))
            overhang_lists = [
                [opt["overhangs"]["overhang_options"][i]
                 for i in range(len(opt["overhangs"]["overhang_options"]))]
                for opt in mutation_set
            ]
            shape = tuple(len(lst) for lst in overhang_lists)
            matrix = np.zeros(shape, dtype=int)
            for combo_indices in product(*[range(len(lst)) for lst in overhang_lists]):
                combo = tuple(overhang_lists[i][idx]
                              for i, idx in enumerate(combo_indices))
                n = len(combo)
                if all(self.compatibility_table[self.utils.seq_to_index(combo[i]["top_overhang"]["seq"])][
                        self.utils.seq_to_index(combo[j]["top_overhang"]["seq"])] == 1
                        for i in range(n) for j in range(i + 1, n)):
                    matrix[combo_indices] = 1
            compatibility_matrices.append(matrix)
        return compatibility_matrices

    @DebugMixin.debug_wrapper
    def filter_compatible_mutations(self, mutation_sets: list, compatibility_matrices: list) -> list:
        indices = [i for i, mat in enumerate(
            compatibility_matrices) if np.all(mat == 0)]
        for i in sorted(indices, reverse=True):
            del mutation_sets[i]
            del compatibility_matrices[i]
        return mutation_sets
